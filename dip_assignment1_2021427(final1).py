# -*- coding: utf-8 -*-
"""DIP_ASSIGNMENT1_2021427(final1)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XXXLW1quEv22Y-4I8Ual_xJM28lpxjzp
"""

!apt-get install poppler-utils

!pip install pdf2image

!apt-get install poppler-utils

from pdf2image import convert_from_path

pdf = 'ruler.pdf'
poppler_path = "/usr/bin/"
images = convert_from_path(pdf, poppler_path=poppler_path)

#converted the pdf into list of images(only 1 page in this case)

images[0].save("ruler"+".jpg","JPEG")

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

#Q1) Applying gaussian blur to the ruler image, kernel sizes=3x3 and 5x5

#a)using 3x3 kernel

input = Image.open('/content/ruler.jpg')
grey_image = input.convert('L')
kernel_size = 3
sigma = 5
#standard deviation will control the level of blur

#getting kernel
x,y =np.meshgrid(np.arange(-kernel_size//2, kernel_size//2 +1),
                   np.arange(-kernel_size//2, kernel_size//2 +1))

gauss_kernel = np.exp(-(x**2 + y**2) / (2*sigma**2))
gauss_kernel /= gauss_kernel.sum()

# Calculating the Gaussian kernel values by Gaussian formula(given in slides)
#normalization(ensures sum of kernel=1)

input_nparr = np.array(grey_image, dtype=np.float32)
output_nparr = np.zeros_like(input_nparr)
# Created an empty np array for the output image

height, width = input_nparr.shape
padding= kernel_size//2
#have used zero padding to handle border case pixels in convolution

for i in range(height):
    for j in range(width):
        area = input_nparr[max(0, i - padding):min(height, i + padding + 1),max(0, j - padding):min(width, j + padding + 1)]
        padded_region = np.zeros_like(gauss_kernel)
        padded_region[:area.shape[0],:area.shape[1]]=area
        output_nparr[i, j] = np.sum(padded_region*gauss_kernel)
#loops for each pixel's position(i,j) to find area of interest
#depending on kernel size for peerforming convolution

blur_imgarr = ((output_nparr - np.min(output_nparr))/(np.max(output_nparr) - np.min(output_nparr)) * 255).astype(np.uint8)
blur_img = Image.fromarray(blur_imgarr)
blur_img.save('ruler(3x3)op.jpg')

x

y

gauss_kernel

import matplotlib.pyplot as plt
plt.imshow(gauss_kernel)

import matplotlib.pyplot as plt
plt.imshow(gauss_kernel1)

import numpy as np
from PIL import Image

#Q1) Applying gaussian blur to the ruler image, kernel sizes=3x3 and 5x5

#b)using 5x5 kernel

input1 = Image.open('/content/ruler.jpg')
grey_image1 = input.convert('L')
kernel_size1 = 5
sigma1 = 5

x1,y1 = np.meshgrid(np.arange(-kernel_size1//2, kernel_size1//2+1),np.arange(-kernel_size1//2, kernel_size1//2+1))
gauss_kernel1=np.exp(-(x1**2 + y1**2) / (2*sigma1**2))
gauss_kernel1/=gauss_kernel1.sum()

input_nparr1 = np.array(grey_image1, dtype=np.float32)
output_nparr1 = np.zeros_like(input_nparr1)

height1, width1 =input_nparr1.shape
padding1=kernel_size1//2

for i in range(height1):
    for j in range(width1):
        area1 =input_nparr1[max(0,i-padding1):min(height1,i+padding1+1),max(0, j - padding1):min(width1,j+padding1+1)]
        padded_region1 =np.zeros_like(gauss_kernel1)
        padded_region1[:area1.shape[0], :area1.shape[1]] = area1
        output_nparr1[i, j] = np.sum(padded_region1 * gauss_kernel1)

blur_imgarr1=((output_nparr1 - np.min(output_nparr1))/(np.max(output_nparr1) - np.min(output_nparr1)) * 255).astype(np.uint8)

blur_img1 = Image.fromarray(blur_imgarr)
blur_img1.save('ruler(5x5)op.jpg')

#Q1) Median filter of kernel 3x3 and 5x5
from PIL import Image
import numpy as np

input2 = Image.open('/content/ruler.jpg')
kernel_size2 = 3
k = kernel_size2 // 2
height2,width2 = input2.size

img_array = np.array(input2)
median_img = Image.new("L", (height2, width2))

for x in range(k, height2 - k):
    for y in range(k, width2 - k):
        adj_pix = img_array[x - k:x + k + 1, y - k:y + k + 1]
        median_val = int(np.median(adj_pix))
        median_img.putpixel((x, y), median_val)
        #using putpixel to set the unput ppixel value to the new median value

median_img.save('median(3x3).jpg')

#Q1) Median filter of kernel 3x3 and 5x5
from PIL import Image
import numpy as np

input2 = Image.open('/content/ruler.jpg')
kernel_size2 = 5
k = kernel_size2 // 2
height2,width2 = input2.size

img_array = np.array(input2)
median_img = Image.new("L", (height2, width2))

for x in range(k, height2 - k):
    for y in range(k, width2 - k):
        adj_pix1= img_array[x-k:x+k+1, y-k:y+k+1]
        median_val= int(np.median(adj_pix1))
        median_img.putpixel((x, y), median_val)
        #using putpixel to set the unput ppixel value to the new median value

median_img.save('median(5x5).jpg')

def gaussian_blur(input_path, kernel_size0, sigma0, output_path):
    inputimg = Image.open(input_path)
    greyimg = inputimg.convert('L')

    x0, y0 = np.meshgrid(np.arange(-kernel_size0//2,kernel_size0//2 +1),np.arange(-kernel_size0//2, kernel_size0//2 +1))

    gauss_kernel0 = np.exp(-(x0**2 + y0**2)/(2*sigma0**2))
    gauss_kernel0 /= gauss_kernel0.sum()

    inarr = np.array(greyimg, dtype=np.float32)
    height0, width0 = inarr.shape
    oparr = np.zeros_like(inarr)

    padding0 =kernel_size0 // 2

    for i in range(height0):
        for j in range(width0):
            area0 = input_nparr[max(0, i - padding0):min(height0, i + padding0 + 1),max(0, j - padding0):min(width0, j + padding0 + 1)]
            padded_region0 = np.zeros_like(gauss_kernel0)
            padded_region0[:area.shape[0], :area.shape[1]] = area
            oparr[i, j] = np.sum(padded_region0 * gauss_kernel0)

    blurarr = ((oparr - np.min(oparr)) /(np.max(oparr) - np.min(oparr)) * 255).astype(np.uint8)

    blurimg = Image.fromarray(blurarr)
    blurimg.save(output_path)

    return blurarr

from pdf2image import convert_from_path
pdf = '/content/tank.pdf'
poppler_path = "/usr/bin/"
images1 = convert_from_path(pdf, poppler_path=poppler_path)
images1[0].save("tank"+".jpg","JPEG")

#Q2)implementing sharpening via first and secind order techniques

#FIRST ORDER TECHNIQUE
#Operator- Unsharp Masking

input4 = Image.open('/content/tank.jpg')
grey_img4 = input4.convert('L')
kernel_size4 = 3
blur=gaussian_blur('/content/tank.jpg',5,5,'blurred_tank.jpg')

grey_np= np.array(grey_img4)
blur_np = np.array(blur)
#numoyarrays of gray and blur img

unsharp_mask = grey_np - blur_np
#applying the formula of unsharp mask(original(gray)-blur)
sharp_factor = 0.1
sharp_np = grey_np + sharp_factor*unsharp_mask

sharp_np = np.clip(sharp_np, 0, 255).astype(np.uint8)
#normalisation

sharpened_image = Image.fromarray(sharp_np)
sharpened_image.save('tank_unsharpmask.jpg')

#convolution as a function to use again and again

import numpy as np
import matplotlib.pyplot as plt

def convolution(image, gauss_kernel):
    height3, width3 = image.shape
    kernel_height,kernel_width =gauss_kernel.shape

    padding_height = kernel_height // 2
    padding_width = kernel_width // 2
    output = np.zeros((height, width), dtype=np.float64)
    padded_image = np.pad(image, ((padding_height, padding_height),(padding_width, padding_width)), mode='constant')

    for i in range(height):
        for j in range(width):
            output[i, j] = np.sum(padded_image[i:i+kernel_height, j:j+kernel_width] * gauss_kernel)

    return output

#laplacian operator

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

input5= Image.open('/content/tank.jpg')
grey_in5 = input5.convert('L')

kernel_size = 3
laplacian_kernel = np.array([[0, 1, 0],
                             [1, -4, 1],
                             [0, 1, 0]], dtype=np.float64)

sigma = 1
blurred_image = gaussian_blur('/content/tank.jpg', kernel_size, sigma, '/content/temp_blur.jpg')

blur_img5 = Image.open('temp_blur.jpg')
blur_img5 = blur_img5.convert('L')

grey_nparr = np.array(grey_in5, dtype=np.float64)
blur_imgarr5 = np.array(blurred_image, dtype=np.float64)

laplacian_img = convolution(blur_imgarr5, laplacian_kernel)
#applied the convolution using laplacian kernel
sharpening_factor = 1.5

sharp_img = grey_nparr+ sharpening_factor*laplacian_img
#formulated the output image by using the formula
sharp_img= np.clip(sharp_img, 0, 255).astype(np.uint8)

op = Image.fromarray(sharp_img)
op.save('laplacian_op.jpg')

plt.imshow(grey_nparr+sharpening_factor*laplacian_img)

#sobel operator

import numpy as np
from PIL import Image
from scipy.ndimage import gaussian_filter

input6 = Image.open('/content/tank.jpg')
grey_in6 = input6.convert('L')

sobel_x = np.array([[-1, 0, 1],
                    [-2, 0, 2],
                    [-1, 0, 1]])

sobel_y = np.array([[-1, -2, -1],
                    [0, 0, 0],
                    [1, 2, 1]])
#horizontal(x) and vertical(y) direction edge detection
plt.imshow(sobel_x)
plt.imshow(sobel_y)
img_arr6= np.array(grey_in6, dtype=np.uint8)

grad_x = convolution(img_arr6, sobel_x)
grad_y = convolution(img_arr6, sobel_y)
grad_mag = np.sqrt(grad_x**2+grad_y**2)
#gradient magnitude

normalised_gradmag = (grad_mag/grad_mag.max())*255
normalised_gradmag = normalised_gradmag.astype(np.uint8)

blur_img6 = gaussian_filter(normalised_gradmag, sigma=1.5)
#have used the custom fn here of gaussian blur
#to smoothen the output image a bit since it was oversharpened

op1 = Image.fromarray(blur_img6)
op1.save('sobel_op.jpg')

plt.imshow(grad_mag)

#operator-laplacian of gaussian

import numpy as np
from PIL import Image

input7 = Image.open('/content/tank.jpg')
grey_img7 = input7.convert('L')

img_arr7= np.array(grey_img7, dtype=np.uint8)
blur_img7 = gaussian_filter(img_arr7, sigma=1.5)

sigma7 = 1.5
size7 = 3
x7, y7 = np.meshgrid(np.linspace(-size7 // 2,size7 // 2, size7),np.linspace(-size7//2, size7//2, size7))
log_kernel =-(x7**2 + y7**2 -(2 * sigma7**2))/ (2 *np.pi*sigma7**4)*np.exp(-(x7**2 + y7**2)/(2*sigma7**2))

log_result = convolution(blur_img7, log_kernel)
normalisation = ((log_result - log_result.min())/(log_result.max() - log_result.min()) * 255).astype(np.uint8)

# Save the LoG edge-detected image
op7 = Image.fromarray(normalisation)
op7.save('laplacianofgaussian_op.jpg')

#operator-robert's gradient

import numpy as np
from PIL import Image

input8 = Image.open('/content/tank.jpg')
grey_img8 = input8.convert('L')

# Convert the input image to a NumPy array
img_arr8 = np.array(grey_img8, dtype=np.uint8)

roberts_x = np.array([[1, 0],
                      [0, -1]])

roberts_y = np.array([[0, 1],
                      [-1, 0]])
#defining robert's kernels for horizontal(x) and vertical(y)pixels as done above

grad_x1 =convolution(img_arr8, roberts_x)

grad_y1 =convolution(img_arr8, roberts_y)
grad_mag1 =np.sqrt(grad_x1**2+grad_y1**2)

normalised_gradmag1 = (grad_mag1/grad_mag1.max())*255
normalised_gradmag1 = normalised_gradmag1.astype(np.uint8)

op8= Image.fromarray(normalised_gradmag1)
op8.save('roberts.jpg')



#operator-prewitt
import numpy as np
from PIL import Image

input9 = Image.open('/content/tank.jpg')
greyimg9=input9.convert('L')

prewitt_x9 = np.array([[-1, 0, 1],
                      [-1, 0, 1],
                      [-1, 0, 1]])

prewitt_y9 = np.array([[-1, -1, -1],
                      [0, 0, 0],
                      [1, 1, 1]])

img_arr9 = np.array(greyimg9)
height, width = img_arr9.shape

grad_x9= convolution(img_arr9, prewitt_x9)
grad_y9= convolution(img_arr9, prewitt_y9)
grad_mag = np.sqrt(grad_x9**2 + grad_y9**2)

op9 = Image.fromarray(np.uint8(grad_mag))
op9.save('prewitt_op.jpg')

